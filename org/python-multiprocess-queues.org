#+TITLE: Comparison of blocking and non-blocking Python's multiprocessing Queue

#+DATE: <2016-04-25>

Python's [[https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Queue][multiprocessing]] module offers a =Queue= implementation. Surprisingly enough (for me at least), its performance varies greatly if used in a blocking or non-blocking fashion. In particular, the non-blocking way is about /ten times slower/ than the blocking one!

Consider this code, which feeds a Queue and then drains it in a blocking and non-blocking way:

#+BEGIN_EXPORT html
  <script src="https://gist.github.com/lbolla/92bad9f4320940ac2f762424ac840a12.js"></script>
#+END_EXPORT

Running it on my machine, with Python 2.7, gives me these results (Python 3.4 results are similar, but less dramatic):

#+BEGIN_EXAMPLE
    feed=0.599231004715 drain=0.964730024338 drain_nowait=8.39909696579
#+END_EXAMPLE

As you can see, =drain_nowait= is about 10x slower than =drain=. I suspect there is some serious lock-contention going on, but I have not yet pinpointed where, exactly! In the meantime, I think I'll stick with the blocking code...
